
.. Foundations 2: Python slides file, created by
   hieroglyph-quickstart on Wed Apr  2 18:42:06 2014.


***************************************************************************
Session Five: Dictionaries, Files, Exceptions
Arguments, Comprehensions, Lambdas and Functional Programming
***************************************************************************

Homework Review
================

.. rst-class:: left
.. container::

* HW 5: Customizing Bash
* HW 6: Mathematical Series
* HW 7: DNA Counting
* HW 11: Mail Room Madness

Ask for volunteers on Slack

Today's Puzzle: Trigrams
========================

Today's Puzzle: Trigrams
========================

N-grams are a way to study word associations

https://books.google.com/ngrams

.. nextslide::

* Coding Kata 14 - Dave Thomas

  http://codekata.com/kata/kata14-tom-swift-under-the-milkwood/

  and in this doc:

  http://codefellows.github.io/sea-c42-python/supplements/kata_fourteen.html

* Use "The Adventures of Sherlock Holmes" as input:

  http://codefellows.github.io/sea-c15-python/_downloads/sherlock_small.txt

.. nextslide::

* Our task today: read in the words from a large text file,
  create a dictionary of trigrams.

* Write pseudo code and create a design.

* Use dictionaries, exceptions, file reading/writing.

Dictionaries and Sets
=====================

Dictionary
----------

Python calls it a ``dict``

Other languages call it:

* dictionary
* associative array
* map
* hash table
* hash
* key-value pair


Dictionary Constructors
-----------------------

.. code-block:: python

    >>> {'key1': 3, 'key2': 5}
    {'key1': 3, 'key2': 5}
    >>> dict([('key1', 3),('key2', 5)])
    {'key1': 3, 'key2': 5}
    >>> dict(key1=3, key2=5)
    {'key1': 3, 'key2': 5}
    >>> d = {}
    >>> d['key1'] = 3
    >>> d['key2'] = 5
    >>> d
    {'key1': 3, 'key2': 5}

Dictionary Indexing
-------------------

.. code-block:: python

    >>> d = {'name': 'Brian', 'score': 42}
    >>> d['score']
    42
    >>> d = {1: 'one', 0: 'zero'}
    >>> d[0]
    'zero'
    >>> d['non-existing key']
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 'non-existing key'


.. nextslide::

Keys can be any **immutable** object:

* number
* string
* tuple

.. code-block:: ipython

    In [325]: d[3] = 'string'
    In [326]: d[3.14] = 'pi'
    In [327]: d['pi'] = 3.14
    In [328]: d[ (1,2,3) ] = 'a tuple key'
    In [329]: d[ [1,2,3] ] = 'a list key'
       TypeError: unhashable type: 'list'


Actually -- any "hashable" type.


.. nextslide:: Hashing

Hash functions convert arbitrarily large data to a small proxy (usually int)

.. rst-class:: build
.. container::

    Always return the same proxy for the same input

    MD5, SHA, etc

    Dictionaries hash the key to an integer proxy and use it to find the key
    and value.

    Key lookup is efficient because the hash function leads directly to a
    bucket with very few keys (often just one)

    What would happen if the proxy changed after storing a key?

    Hashability requires immutability

    Key lookup is very efficient

    Same average time regardless of size


.. nextslide:: Dictionary indexing


Note: Python name look-ups are implemented with dict -- it's highly optimized

.. rst-class:: build
.. container::

    Key to value:

    * lookup is one way

    Value to key:

    * requires visiting the whole dict

    If you need to check dict values often, create another dict or set

    (up to you to keep them in sync)


Dictionary Ordering (not)
-------------------------

Dictionaries have no defined order

.. code-block:: ipython

    In [352]: d = {'one':1, 'two':2, 'three':3}
    In [353]: d
    Out[353]: {'one': 1, 'three': 3, 'two': 2}
    In [354]: d.keys()
    Out[354]: ['three', 'two', 'one']

.. rst-class:: build
.. container::

    You will be fooled by what you see into thinking that the order of pairs
    can be relied on.

    It cannot.

Dictionary Iterating
--------------------

``for``  iterates over the keys

.. code-block:: ipython

    In [15]: d = {'name': 'Brian', 'score': 42}

    In [16]: for x in d:
       ....:     print(x)
       ....:
    score
    name


(note the different order...)

dict keys and values
--------------------

.. code-block:: ipython

    In [20]: d = {'name': 'Brian', 'score': 42}

    In [21]: d.keys()
    Out[21]: ['score', 'name']

    In [22]: d.values()
    Out[22]: [42, 'Brian']

    In [23]: d.items()
    Out[23]: [('score', 42), ('name', 'Brian')]


dict keys and values
--------------------

Iterating on everything

.. code-block:: ipython

    In [26]: d = {'name': 'Brian', 'score': 42}

    In [27]: for k, v in d.items():
       ....:     print("%s: %s" % (k,v))
       ....:
    score: 42
    name: Brian


Dictionary Performance
-----------------------

* indexing is fast and constant time: O(1)

* Membership (``x in s``) constant time: O(1)

* visiting all is proportional to n: O(n)

* inserting is constant time: O(1)

* deleting is constant time: O(1)

http://wiki.python.org/moin/TimeComplexity


Other dict operations:
----------------------

See them all here:

https://docs.python.org/2/library/stdtypes.html#mapping-types-dict

Is it in there?

.. code-block:: ipython

    In [5]: d
    Out[5]: {'that': 7, 'this': 5}

    In [6]: 'that' in d
    Out[6]: True

    In [7]: 'this' not in d
    Out[7]: False

Membership is on the keys.

.. nextslide:: Getting Something

(like indexing)

.. code-block:: ipython

    In [9]: d.get('this')
    Out[9]: 5

.. rst-class:: build
.. container::

    But you can specify a default

    .. code-block:: ipython

        In [11]: d.get(u'something', u'a default')
        Out[11]: u'a default'

    Never raises an Exception (default default is None)

.. nextslide:: Iterating

.. code-block:: ipython

  In [13]: for item in d.iteritems():
     ....:     print item
     ....:
  ('this', 5)
  ('that', 7)
  In [15]: for key in d.keys():
     ....:     print key
     ....:
  this
  that
  In [16]: for val in d.values():
     ....:     print val
     ....:
  5
  7

the ``iter*`` methods *don't actually create the lists*.

.. nextslide:: Popping

gets the value at a given key while removing it

.. rst-class:: build
.. container::

    Pop just a key

    .. code-block:: ipython

        In [19]: d.pop('this')
        Out[19]: 5
        In [20]: d
        Out[20]: {'that': 7}

    pop out an arbitrary key, value pair

    .. code-block:: ipython

        In [23]: d.popitem()
        Out[23]: ('that', 7)
        In [24]: d
        Out[24]: {}

.. nextslide:: Handy Method

``setdefault(key[, default])``

gets the value if it's there, sets it if it's not

.. code-block:: ipython

    In [26]: d = {}

    In [27]: d.setdefault(u'something', u'a value')
    Out[27]: u'a value'
    In [28]: d
    Out[28]: {u'something': u'a value'}
    In [29]: d.setdefault(u'something', u'a different value')
    Out[29]: u'a value'
    In [30]: d
    Out[30]: {u'something': u'a value'}

.. nextslide::

dict View objects:

Like ``keys()``, ``values()``, ``items()``, but maintain a link to the original dict

.. code-block:: ipython

  In [47]: d
  Out[47]: {u'something': u'a value'}
  In [48]: item_view = d.viewitems()
  In [49]: item_view
  Out[49]: dict_items([(u'something', u'a value')])
  In [50]: d['something else'] = u'another value'

  In [51]: item_view
  Out[51]: dict_items([('something else', u'another value'), (u'something', u'a value')])

Sets
----

A ``set``  is an unordered collection of distinct values

Essentially a dict with only keys

Set Constructors

.. code-block:: ipython

    >>> set()
    set([])

    >>> set([1, 2, 3])
    set([1, 2, 3])

    >>> {1, 2, 3}
    set([1, 2, 3])

    >>> s = set()

    >>> s.update([1, 2, 3])
    >>> s
    set([1, 2, 3])


Set Properties
---------------

``Set``  members must be hashable

.. rst-class:: build
.. container::

    Like dictionary keys -- and for same reason (efficient lookup)

    No indexing (unordered)

    .. code-block:: ipython

        >>> s[1]
        Traceback (most recent call last):
          File "<stdin>", line 1, in <module>
        TypeError: 'set' object does not support indexing


Set Methods
-----------

.. code-block:: ipython

    >>> s = set([1])
    >>> s.pop() # an arbitrary member
    1
    >>> s.pop()
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 'pop from an empty set'
    >>> s = set([1, 2, 3])
    >>> s.remove(2)
    >>> s.remove(2)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    KeyError: 2

.. nextslide::

All the "set" operations from math class...

.. code-block:: python

    s.isdisjoint(other)

    s.issubset(other)

    s.union(other, ...)

    s.intersection(other, ...)

    s.difference(other, ...)

    s.symmetric_difference( other, ...)

Frozen Set
----------

Another kind of set: ``frozenset``

immutable -- for use as a key in a dict
(or another set...)

.. code-block:: python

    >>> fs = frozenset((3,8,5))
    >>> fs.add(9)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    AttributeError: 'frozenset' object has no attribute 'add'


Exceptions
==========

.. rst-class:: left
.. container::

    Another Branching structure:

    .. code-block:: python

        try:
            do_something()
            f = open('missing.txt')
            process(f)   # never called if file missing
        except IOError:
            print "couldn't open missing.txt"

Exceptions
----------

Never Do this:

.. code-block:: python

    try:
        do_something()
        f = open('missing.txt')
        process(f)   # never called if file missing
    except:
        print "couldn't open missing.txt"


Exceptions
----------

Use Exceptions, rather than your own tests:

Don't do this:

.. code-block:: python

    do_something()
    if os.path.exists('missing.txt'):
        f = open('missing.txt')
        process(f)   # never called if file missing

It will almost always work -- but the almost will drive you crazy

.. nextslide::

Example from homework

.. code-block:: python

    if num_in.isdigit():
        num_in = int(num_in)

but -- ``int(num_in)`` will only work if the string can be converted to an integer.

So you can do

.. code-block:: python

    try:
        num_in = int(num_in)
    except ValueError:
        print(u"Input must be an integer, try again.")

Or let the Exception be raised....


.. nextslide:: EAFP

::

    "it's Easier to Ask Forgiveness than Permission"

    -- Grace Hopper

http://www.youtube.com/watch?v=AZDWveIdqjY

(Pycon talk by Alex Martelli)

.. nextslide:: Do you catch all Exceptions?

For simple scripts, let exceptions happen.

Only handle the exception if the code can and will do something about it.

(much better debugging info when an error does occur)


Exceptions -- finally
---------------------

.. code-block:: python

    try:
        do_something()
        f = open('missing.txt')
        process(f)   # never called if file missing
    except IOError:
        print(u"couldn't open missing.txt")
    finally:
        do_some_clean-up

The ``finally:``  clause will always run


Exceptions -- else
-------------------

.. code-block:: python

    try:
        do_something()
        f = open('missing.txt')
    except IOError:
        print(u"couldn't open missing.txt")
    else:
        process(f) # only called if there was no exception

Advantage:
  you know where the Exception came from

Exceptions -- using them
------------------------

.. code-block:: python

    try:
        do_something()
        f = open('missing.txt')
    except IOError as the_error:
        print the_error
        the_error.extra_info = "some more information"
        raise

.. rst-class:: build
.. container::

    Particularly useful if you catch more than one exception:

    .. code-block:: python

        except (IOError, BufferError, OSError) as the_error:
            do_something_with (the_error)


Raising Exceptions
------------------

.. code-block:: python

    def divide(a,b):
        if b == 0:
            raise ZeroDivisionError("b can not be zero")
        else:
            return a / b

.. rst-class:: build
.. container::

    when you call it:

    .. code-block:: ipython

        In [515]: divide (12,0)
        ZeroDivisionError: b can not be zero


Built in Exceptions
-------------------

You can create your own custom exceptions, but...

.. rst-class:: build
.. container::

    .. code-block:: python

        exp = [name for name in dir(__builtin__) if "Error" in name]
        len(exp)
        32

    For the most part, you can/should use a built in one

.. nextslide::

Choose the best match you can for the built in Exception you raise.

.. rst-class:: build
.. container::

    Example (for last week's ackerman homework)::

        if (not isinstance(m, int)) or (not isinstance(n, int)):
            raise ValueError

    Is the *value* of the input the problem here?

    Nope: the *type* is the problem::

        if (not isinstance(m, int)) or (not isinstance(n, int)):
            raise TypeError

    but should you be checking type anyway? (EAFP)


File Reading and Writing
========================

Files
-----

Text Files

.. code-block:: python

    f = open('secrets.txt', encoding='utf-8')
    secret_data = f.read()
    f.close()

``secret_data`` is a (unicode) string

``encoding`` defaults to ``sys.getdefaultencoding()`` -- often NOT what you
want.


.. nextslide::

Binary Files

.. code-block:: python

    f = open('secrets.bin', 'rb')
    secret_data = f.read()
    f.close()

``secret_data``  is a byte string

(with arbitrary bytes in it -- well, not arbitrary -- whatever is in the file.)

(See the ``struct``  module to unpack formatted binary data)


.. nextslide::

File Opening Modes

.. code-block:: python

    f = open('secrets.txt', [mode])
    'r', 'w', 'a'
    'rb', 'wb', 'ab'
    r+, w+, a+
    r+b, w+b, a+b
    U
    U+

These follow the Unix conventions, and aren't all that well documented on the
Python docs. But these BSD docs make it pretty clear:

http://www.manpagez.com/man/3/fopen/

**Gotcha** -- 'w' modes always clear the file

.. nextslide:: Text File Notes

Text is default

* Newlines are translated: ``\r\n -> \n``
*   -- reading and writing!
* Use \*nix-style in your code: ``\n``
* ``io.open()`` returns various "stream" objects -- but they act like file
  objects.
* In text mode, open() defaults to "Universal" newline mode.


Gotcha:

* no difference between text and binary on \*nix
* breaks on Windows


.. nextslide:: Other parameters to ``io.open()``:

``open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True)``

* ``file`` is generally a file name or full path

* ``mode`` is the mode for opening: 'r', 'w', etc.

* ``buffering`` controls the buffering mode (0 for no buffering)

* ``encoding`` sets the unicode encoding -- only for text files -- when set,
  you can ONLY write unicode object to the file.

* ``errors`` sets the encoding error mode: 'strict', 'ignore', 'replace',...

* ``newline`` controls Universal Newline mode: lets you write DOS-type files on
  \*nix, for instance (text mode only).

* ``closedfd`` controls close()  behavior if a file descriptor, rather than a
  name is passed in (advanced usage!)

(https://docs.python.org/2/library/io.html?highlight=io.open#io.open)


File Reading
------------

Reading part of a file

.. code-block:: python

    header_size = 4096
    f = open('secrets.txt')
    secret_header = f.read(header_size)
    secret_rest = f.read()
    f.close()

.. nextslide::


Common Idioms

.. code-block:: python

    for line in open('secrets.txt'):
        print line

.. rst-class:: build
.. container::

    (the file object is an iterator!)

    .. code-block:: python

        f = io.open('secrets.txt')
        while True:
            line = f.readline()
            if not line:
                break
            do_something_with_line()


File Writing
------------

.. code-block:: python

    outfile = open('output.txt', 'w')
    for i in range(10):
        outfile.write("this is line: %i\n"%i)


File Methods
------------

Commonly Used Methods

.. code-block:: python

    f.read() f.readline() f.readlines()

    f.write(str) f.writelines(seq)

    f.seek(offset) f.tell()

    f.flush()

    f.close()


Trigram Puzzle
================

.. rst-class:: left
.. container::

Today's Puzzle: Trigrams
========================

N-grams are a way to study word associations

https://books.google.com/ngrams


* Our task today: read in the words from a large text file,
  create a dictionary of trigrams.

* Write pseudo code and create a design.

* Use dictionaries, exceptions, file reading/writing.
    .. rst-class:: build

        * Dictionaries
        * Exceptions
        * Files, etc.

Homework for Next Time
======================

HW 12 : Update Mailroom Madness with dicts and files
HW 13 : Trigrams

Homework Review
---------------

Homework Questions?

Solutions to the dict/set lab, and some others in the class repo in:
``Solutions``

A few tidbits:

.. nextslide:: Sorting Dictionaries:

The ``dict`` isn't sorted, so what if you want to do something in a sorted way?

.. rst-class:: build
.. container::

    The "old" way:

    .. code-block:: python

        keys = d.keys()
        keys.sort()
        for key in keys:
            ...

    .. code-block:: python

        collections.OrderedDict
        sorted()

    (demo)


Advanced Argument Passing
=========================

Keyword arguments
-----------------

When defining a function, you can specify only what you need -- in any order

.. code-block:: ipython

    In [150]: from __future__ import print_function
    In [151]: def fun(x, y=0, z=0):
       .....:     print(x, y, z, end=" ")
       .....:
    In [152]: fun(1, 2, 3)
    1 2 3
    In [153]: fun(1, z=3)
    1 0 3
    In [154]: fun(1, z=3, y=2)
    1 2 3

.. nextslide::

A Common Idiom:

.. code-block:: python

    def fun(x, y=None):
        if y is None:
            do_something_different
        go_on_here

.. nextslide::

Can set defaults to variables

.. code-block:: ipython

    In [156]: y = 4
    In [157]: def fun(x=y):
        print(u"x is: %s" % x)
       .....:
    In [158]: fun()
    x is: 4

.. nextslide:: But Remember

Defaults are evaluated when the function is defined

.. code-block:: ipython

    In [156]: y = 4
    In [157]: def fun(x=y):
        print(u"x is: %s" % x)
       .....:
    In [158]: fun()
    x is: 4
    In [159]: y = 6
    In [160]: fun()
    x is: 4

Function arguments in variables
-------------------------------

function arguments are really just:

.. rst-class:: build
.. container::

    * a tuple (positional arguments)
    * a dict (keyword arguments)

    .. code-block:: python

        In [1]: def f(x, y, w=0, h=0):
           ...:     msg = u"position: %s, %s -- shape: %s, %s"
           ...:     print(msg % (x, y, w, h))
           ...:
        In [2]: position = (3, 4)
        In [3]: size = {'h': 10, 'w': 20}
        In [4]: f(*position, **size)
        position: 3, 4 -- shape: 20, 10

Function parameters in variables
--------------------------------

You can also pull the parameters out in the function as a tuple and a dict:

.. code-block:: ipython

    In [10]: def f(*args, **kwargs):
       ....:     print(u"the positional arguments are: %s" % unicode(args))
       ....:     print(u"the optional arguments are: %s" % unicode(kwargs))
       ....:
    In [11]: f(2, 3, this=5, that=7)
    the positional arguments are: (2, 3)
    the optional arguments are: {'this': 5, 'that': 7}

Passing a dict to the ``string.format()`` method
------------------------------------------------

Now that you know that keyword args are really a dict, you can do this nifty
trick:

.. rst-class:: build
.. container::

    .. container::

        The ``format`` method takes keyword arguments:

        .. code-block:: ipython

            In [24]: u"My name is {first} {last}".format(last=u"Ewing", first=u"Cris")
            Out[24]: u'My name is Cris Ewing'

    .. container::

        Build a dict of the keys and values:

        .. code-block:: ipython

            In [25]: d = {u"last": u"Ewing", u"first": u"Cris"}

    .. container::

        And pass to ``format()``with ``**``

        .. code-block:: ipython

            In [26]: u"My name is {first} {last}".format(**d)
            Out[26]: u'My name is Paul Pham'

LAB
---

Let's do this right now:

.. rst-class:: build
.. container::

    keyword arguments

    .. rst-class:: build

        * Write a function that has four optional parameters (with defaults):

          - foreground_color
          - background_color
          - link_color
          - visited_link_color

        * Have it print the colors (use strings for the colors)
        * Call it with a couple different parameters set
        * Have it pull the parameters out with ``*args, **kwargs``


A bit more on mutability (and copies)
=====================================

.. rst-class:: left

We've talked about this: mutable objects can have their contents changed in
place.

.. rst-class:: left build
.. container::

    Immutable objects can not.

    This has implications when you have a container with mutable objects in it:

    .. code-block:: ipython

        In [28]: list1 = [ [1,2,3], ['a','b'] ]

    one way to make a copy of a list:

    .. code-block:: ipython

        In [29]: list2 = list1[:]
        In [30]: list2 is list1
        Out[30]: False

    they are different lists.

mutable objects
---------------

What if we set an element to a new value?

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [31]: list1[0] = [5,6,7]

        In [32]: list1
        Out[32]: [[5, 6, 7], ['a', 'b']]

        In [33]: list2
        Out[33]: [[1, 2, 3], ['a', 'b']]

    So they are independent.

.. nextslide::

But what if we mutate an element?

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [34]: list1[1].append('c')

        In [35]: list1
        Out[35]: [[5, 6, 7], ['a', 'b', 'c']]

        In [36]: list2
        Out[36]: [[1, 2, 3], ['a', 'b', 'c']]

    uh oh! mutating an element in one list mutated the one in the other list.

.. nextslide::

Why is that?

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [38]: list1[1] is list2[1]
        Out[38]: True

    The elements are the same object!

    This is known as a "shallow" copy -- Python doesn't want to copy more than
    it needs to, so in this case, it makes a new list, but does not make copies
    of the contents.

    Same for dicts (and any container type)

    If the elements are immutable, it doesn't really make a differnce -- but be
    very careful with mutable elements.


The copy module
--------------------

most objects have a way to make copies (``dict.copy()`` for instance).

.. rst-class:: build
.. container::

    but if not, you can use the ``copy`` module to make a copy:

    .. code-block:: ipython

        In [39]: import copy

        In [40]: list3 = copy.copy(list2)

        In [41]: list3
        Out[41]: [[1, 2, 3], ['a', 'b', 'c']]

    This is *also* a shallow copy.

.. nextslide::

But there is another option:

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [3]: list1
        Out[3]: [[1, 2, 3], ['a', 'b', 'c']]

        In [4]: list2 = copy.deepcopy(list1)

        In [5]: list1[0].append(4)

        In [6]: list1
        Out[6]: [[1, 2, 3, 4], ['a', 'b', 'c']]

        In [7]: list2
        Out[7]: [[1, 2, 3], ['a', 'b', 'c']]

    ``deepcopy`` recurses through the object, making copies of everything as it goes.

.. nextslide::

I happened on this thread on stack overflow:

http://stackoverflow.com/questions/3975376/understanding-dict-copy-shallow-or-deep

.. rst-class:: build
.. container::

    The OP is pretty confused -- can you sort it out?

    Make sure you understand the difference between a reference, a shallow
    copy, and a deep copy.

Mutables as default arguments:
------------------------------

Another "gotcha" is using mutables as default arguments:

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [11]: def fun(x, a=[]):
           ....:     a.append(x)
           ....:     print(a)
           ....:

    This makes sense: maybe you'd pass in a list, but the default is an empty list.

    .. container::

        But:

        .. code-block:: ipython

            In [12]: fun(3)
            [3]

            In [13]: fun(4)
            [3, 4]

    Huh?!

.. nextslide::

Remember:

.. rst-class:: build

* the default argument is defined when the function is created
* there will be *only one list*
* every time the function is called, the *same one list* is used.

.. rst-class:: build
.. container::

    The standard practice for such a mutable default argument:

    .. code-block:: ipython

        In [15]: def fun(x, a=None):
           ....:     if a is None:
           ....:         a = []
           ....:     a.append(x)
           ....:     print(a)
        In [16]: fun(3)
        [3]
        In [17]: fun(4)
        [4]

    You get a new list every time the function is called


List and Dict Comprehensions
============================

.. rst-class:: left
.. container::

    A bit of functional programming

    .. rst-class:: build
    .. container::

        consider this common ``for`` loop structure:

        .. code-block:: python

            new_list = []
            for variable in a_list:
                new_list.append(expression)

        This can be expressed with a single line using a "list comprehension"

        .. code-block:: python

            new_list = [expression for variable in a_list]

List Comprehensions
-------------------

What about nested for loops?

.. rst-class:: build
.. container::

    .. code-block:: python

        new_list = []
        for var in a_list:
            for var2 in a_list2:
                new_list.append(expression)

    Can also be expressed in one line:

    .. code-block:: python

        new_list =  [exp for var in a_list for var2 in a_list2]

    You get the "outer product", i.e. all combinations.

    (demo)

.. nextslide::

But usually you at least have a conditional in the loop:

.. rst-class:: build
.. container::

    .. code-block:: python

        new_list = []
        for variable in a_list:
            if something_is_true:
                new_list.append(expression)

    You can add a conditional to the comprehension:

    .. code-block:: python

        new_list = [expr for var in a_list if something_is_true]

    (demo)

.. nextslide::

Examples:

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [341]: [x ** 2 for x in range(3)]
        Out[341]: [0, 1, 4]

        In [342]: [x + y for x in range(3) for y in range(5, 7)]
        Out[342]: [5, 6, 6, 7, 7, 8]

        In [343]: [x * 2 for x in range(6) if not x % 2]
        Out[343]: [0, 4, 8]

    Remember this from last week?

    .. code-block:: python

        [name for name in dir(__builtin__) if "Error" in name]
        ['ArithmeticError',
         'AssertionError',
         'AttributeError',
         ....


Set Comprehensions
------------------

You can do it with sets, too:

.. rst-class:: build
.. container::

    .. code-block:: python

        new_set = {value for value in a_sequence}


    the same as this ``for`` loop:

    .. code-block:: python

        new_set = set()
        for value in a_sequence:
            new_set.add(value)

.. nextslide::

Example: finding all the vowels in a string...

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [19]: s = "a not very long string"

        In [20]: vowels = set('aeiou')

        In [21]: { let for let in s if let in vowels }
        Out[21]: {'a', 'e', 'i', 'o'}

    Side note: why did I do ``set('aeiou')`` rather than just `aeiou`\ ?


Dict Comprehensions
-------------------

Also with dictionaries

.. rst-class:: build
.. container::

    .. code-block:: python

        new_dict = { key:value for key, value in a_sequence}


    the same as this ``for`` loop:

    .. code-block:: python

        new_dict = {}
        for key, value in a_sequence:
            new_dict[key] = value

.. nextslide::

Example

.. rst-class:: build
.. container::

    .. code-block:: ipython

        In [22]: {i: "this_%i" % i for i in range(5)}
        Out[22]: {0: 'this_0', 1: 'this_1', 2: 'this_2',
                  3: 'this_3', 4: 'this_4'}

    Can you do the same thing with the ``dict()`` constructor?


Recommended Reading
---------------------

* LPTHW: Ex 40 - 45

http://learnpythonthehardway.org/book/

* Dive Into Python: chapter 4, 5

http://www.diveintopython.net/toc/index.html

